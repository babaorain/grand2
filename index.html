<!DOCTYPE html>
<html lang="zh-Hant-TW">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ğŸ¥ å¾©å¥ç§‘ Grandrun å ±å‘Šç”¢ç”Ÿå™¨</title>
  <style>
    /* =====================
       Light UI â€” clean, clinical, print-friendly
       ===================== */
    :root{
      /* Color system */
      --bg: #ffffff;
      --bg-weak:#f8fafc; /* panels / subtle backgrounds */
      --card:#ffffff;
      --ink:#111827;     /* main text (near-black) */
      --muted:#6b7280;   /* secondary text */
      --accent:#2563eb;  /* primary action */
      --accent2:#0891b2; /* secondary accent */
      --border:#e5e7eb;  /* soft border */
      --ok:#059669;      /* success */
      --warn:#b91c1c;    /* warning */

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans TC, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --radius: 14px;
      --shadow: 0 4px 16px rgba(17,24,39,.06);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body{
      margin:0; background: var(--bg); color: var(--ink);
      font-family: var(--sans); line-height: 1.65; letter-spacing:.2px;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    }

    .wrap{ max-width: 1200px; margin: 32px auto 40px; padding: 0 16px; }

    /* Header */
    .header{ display:flex; align-items:baseline; gap:12px; flex-wrap:wrap; margin-bottom: 18px; }
    h1{ font-size: clamp(22px,2.2vw,28px); margin:0; font-weight:800; color:#0f172a }
    .sub{ color: var(--muted); font-size:14px }

    /* Grid */
    .grid{ display:grid; grid-template-columns: 1fr; gap:16px; }
    @media (min-width: 1024px){ .grid{ grid-template-columns: 1fr 1fr; gap:18px; } }

    /* Card */
    .card{ background: var(--card); border:1px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow); overflow:hidden }
    .card h2{ margin:0; padding:14px 16px; border-bottom:1px solid var(--border); font-size:16px; color:#111827; background:var(--bg-weak); }
    .card .body{ padding: 14px; }

    /* Form */
    label{ display:block; font-size:12px; color: var(--muted); margin:8px 2px; }
    textarea{ width:100%; min-height:160px; resize:vertical; padding:12px 12px; border-radius: 12px; background:#ffffff; color:#111827;
              border:1px solid var(--border); font-family: var(--mono); font-size: 13px; transition: border-color .15s, box-shadow .15s; }
    textarea:focus{ outline:none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(37,99,235,.15) }
    .h200{ min-height:200px } .h260{ min-height:260px } .h340{ min-height:340px }

    /* Actions */
    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center }
    button{
      border:1px solid var(--accent); background: var(--accent); color:#ffffff;
      padding:10px 14px; border-radius: 12px; cursor:pointer; font-weight:700; transition:.2s transform, .2s filter;
    }
    button:hover{ transform: translateY(-1px); filter:brightness(1.05) }
    button:active{ transform: translateY(0) scale(.98) }
    .ghost{ background: #ffffff; color: var(--accent); border:1px solid var(--accent); }

    .pill{ padding: 6px 10px; border-radius: 999px; font-size: 12px; border:1px dashed var(--border); color:var(--muted) }

    /* Output */
    .out{ white-space: pre-wrap; background:#ffffff; border:1px solid var(--border); border-radius: 12px; padding:12px; font-family: var(--mono); font-size: 13px; color:#111827 }

    /* Footer */
    .footer{ margin: 28px 0 10px; color: var(--muted); font-size:12px }

    /* Status */
    .ok{ color: var(--ok); font-weight:700 }
    .warn{ color: var(--warn); font-weight:700 }
    .right{ margin-left:auto }
    .muted{ color: var(--muted) }
    .tiny{ font-size: 12px }

    /* Better focus ring for buttons */
    button:focus-visible{ outline: 3px solid rgba(37,99,235,.25); outline-offset: 2px }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <h1>ğŸ¥ å¾©å¥ç§‘ Grandrun å ±å‘Šç”¢ç”Ÿå™¨</h1>
      <div class="sub">é«˜é†«å¾©å¥ç§‘</div>
    </div>

    <div class="grid">
      <div class="card">
        <h2>è¼¸å…¥</h2>
        <div class="body">
          <label>è¨ºæ–· (Diagnosis)</label>
          <textarea id="diagnosis" class="h200" placeholder="åœ¨æ­¤è²¼ä¸Šè¨ºæ–·æ‘˜è¦â€¦"></textarea>

          <label>PE / Functional status / Local finding</label>
          <textarea id="pe" class="h260" placeholder="åœ¨æ­¤è²¼ä¸Š PEã€åŠŸèƒ½ç‹€æ…‹ã€Local findingâ€¦"></textarea>

          <label>HTMLï¼ˆæ²»ç™‚é†«å›‘ï¼ŒåŸæª” HTML ç‰‡æ®µäº¦å¯ï¼‰</label>
          <textarea id="htmltext" class="h200" placeholder="åœ¨æ­¤è²¼ä¸Š HTML ç‰‡æ®µæˆ–é—œéµå­—/ç¸®å¯«â€¦"></textarea>

          <div class="row" style="margin-top:10px">
            <button id="gen">ç”¢ç”Ÿå ±å‘Š</button>
            <button id="copy" class="ghost">è¤‡è£½å ±å‘Š</button>
            <button id="save" class="ghost">ä¸‹è¼‰ .txt</button>
            <span id="status" class="tiny muted"></span>
            <span class="right tiny muted">æœ¬é è³‡æ–™æš«å­˜æ–¼ç€è¦½å™¨ localStorage</span>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>è¼¸å‡º</h2>
        <div class="body">
          <div id="out" class="out h340" placeholder="å ±å‘Šå°‡é¡¯ç¤ºæ–¼æ­¤â€¦"></div>
        </div>
      </div>
    </div>

    <div class="footer tiny">
      Grand Run å¥½ç…©
    </div>
  </div>

<script>
(function(){
  const $ = (sel)=>document.querySelector(sel);
  const diagnosis = $('#diagnosis');
  const pe = $('#pe');
  const htmltext = $('#htmltext');
  const out = $('#out');
  const status = $('#status');

  // ===== å°å·¥å…· =====
  const box = (b)=> b ? 'â– ' : 'â–¡';
  const safeLower = (s)=> (s||'').toLowerCase();
  const reTest = (re, s)=> re.test(s||'');
  const findAll = (re, s)=> Array.from((s||'').matchAll(re));

  // å„²å­˜/è¼‰å…¥ï¼ˆlocalStorageï¼‰
  const persistKey = 'grandrun-static-v1';
  try{
    const saved = JSON.parse(localStorage.getItem(persistKey)||'null');
    if(saved){ diagnosis.value = saved.dx||''; pe.value = saved.pe||''; htmltext.value = saved.html||''; }
  }catch(e){}
  function persist(){ try{ localStorage.setItem(persistKey, JSON.stringify({dx: diagnosis.value, pe: pe.value, html: htmltext.value})) }catch(e){} }
  diagnosis.addEventListener('input', persist); pe.addEventListener('input', persist); htmltext.addEventListener('input', persist);

  // ===== ç‰ˆæœ¬åˆ¤å®š =====
  function detectCaseType(dx){
    const d = safeLower(dx);
    if (/\b(sci|spinal\s*cord\s*injury)\b/i.test(d)) return 'SCI';
    if (/\b(tbi|traumatic\s*brain\s*injury|head\s*injury)\b/i.test(d)) return 'TBI';
    return 'CVA';
  }

  // ===== åç™±å´ =====
  function inferHemiparesisSide(dx){
    const t = safeLower(dx||'');
    const R = [/\bright(?:[-\s]*sided)?\s*(?:hemi(?:paresis|plegia)|weakness)\b/i,
               /(?:hemi(?:paresis|plegia)|weakness)\b[^.\n]*\bright(?:[-\s]*side)?\b/i,
               /\brt?\.?\s*(?:hemi(?:paresis|plegia)|weakness)\b/i,
               /\br(?:ight)?\s*side\b[^.\n]*\bhemi(?:paresis|plegia)\b/i,
               /\brhp\b/i];
    const L = [/\bleft(?:[-\s]*sided)?\s*(?:hemi(?:paresis|plegia)|weakness)\b/i,
               /(?:hemi(?:paresis|plegia)|weakness)\b[^.\n]*\bleft(?:[-\s]*side)?\b/i,
               /\blt?\.?\s*(?:hemi(?:paresis|plegia)|weakness)\b/i,
               /\bl(?:eft)?\s*side\b[^.\n]*\bhemi(?:paresis|plegia)\b/i,
               /\blhp\b/i];
    if (R.some(r=>r.test(t))) return 'right';
    if (L.some(r=>r.test(t))) return 'left';
    return null;
  }
  function _mpToFloat(s){
    if(!s) return NaN; s = String(s).trim().toUpperCase();
    if(s==='NT') return NaN;
    const nums = s.match(/[0-5]/g);
    if(!nums) return NaN; // å–æœ€ä½
    return Math.min(...nums.map(n=>parseInt(n,10)));
  }
  function inferHemiparesisSideFromMP(pet){
    const t = pet||''; let cands=[];
    let r1 = findAll(/\bR(?:ight)?[^:\n]{0,20}MP\s*[:ï¼š]?\s*([0-5][+-]?)/ig, t).map(m=>m[1]);
    let l1 = findAll(/\bL(?:eft)?[^:\n]{0,20}MP\s*[:ï¼š]?\s*([0-5][+-]?)/ig, t).map(m=>m[1]);
    let r2 = findAll(/MP\s*\(\s*R(?:ight)?\s*\)\s*[:ï¼š]?\s*([0-5][+-]?)/ig, t).map(m=>m[1]);
    let l2 = findAll(/MP\s*\(\s*L(?:eft)?\s*\)\s*[:ï¼š]?\s*([0-5][+-]?)/ig, t).map(m=>m[1]);
    const parts = findAll(/\b(R|L)(?:UE|LE)\b[^:\n]{0,20}MP\s*[:ï¼š]?\s*([0-5][+-]?)/ig, t);
    const avg = (arr)=> arr.length? (arr.reduce((a,b)=>a+_mpToFloat(b),0)/arr.length) : NaN;
    let rVals=[...r1,...r2], lVals=[...l1,...l2];
    parts.forEach(m=>{ (m[1].toUpperCase()==='R'? rVals:lVals).push(m[2]) });
    const r = avg(rVals), l = avg(lVals);
    if(!isNaN(r) && !isNaN(l)){
      if (r + 0.5 <= l) return 'right';
      if (l + 0.5 <= r) return 'left';
    }
    return null;
  }

  // ===== Brunnstrom / MAS =====
  function parseBrunnstromBlock(pet){
    const pe = pet||''; let side='Right', parts=null;
    let mL = pe.match(/left\s*limbs\s*:\s*([IVXivx\-\s\/]+)/i);
    let mR = pe.match(/right\s*limbs\s*:\s*([IVXivx\-\s\/]+)/i);
    if (mR){ side='Right'; parts = mR[1]; }
    if (mL){ side='Left';  parts = mL[1]; }
    let up='NA', ud='NA', ll='NA';
    if(parts){ const seg = parts.split('/').map(s=>s.trim()).filter(Boolean); if(seg.length===3){ [up,ud,ll]=seg; } }
    return {side, up, ud, ll};
  }
  function defaultMAS(){ return { R1:'0/0/0', R2:'0/0', L1:'0/0/0', L2:'0/0' }; }

  // ===== èªçŸ¥ =====
  function inferCognitionLevel(pet){
    const p = safeLower(pet||'');
    if (/comprehension\s*:\s*(impaired|poor|decreased|abnormal)/i.test(p)) return 'å·®';
    if (/comprehension\s*:\s*(fair|fair~good)/i.test(p)) return 'å°šå¯';
    if (/cognition[^:\n]*\b(poor|impaired|decreased|abnormal)\b/i.test(p)) return 'å·®';
    if (/cognition[^:\n]*\bfair\b/i.test(p)) return 'å°šå¯';
    return 'è‰¯';
  }

  // ===== Local finding tubes =====
  function parseLocalFindingTubes(pet){
    const lines = (pet||'').split(/\n+/).map(s=>s.trim().toLowerCase()).filter(Boolean); let ng=false, foley=false, tr=false;
    for(let i=lines.length-1;i>=0;i--){ const ln=lines[i]; if(ln.startsWith('local finding')){
      if(/ng[^a-z0-9]*\+/i.test(ln)) ng=true; if(/foley[^a-z0-9]*\+/i.test(ln)) foley=true; if(/(tracheostomy|tr\.)[^a-z0-9]*\+/i.test(ln)) tr=true; break; } }
    return {ng, foley, tr};
  }

  // ===== å¤±èª/ååš¥/æ°£åˆ‡ =====
  function inferAphasiaTypes(dx, pet){
    const d = safeLower(dx||''), p = safeLower(pet||'');
    const exprKeys = [/\bbroca\b/i, /\bmotor\b/i, /\bexpressive\b/i, /\btranscortical\s*motor\b/i, /\btcma\b/i];
    const recepKeys = [/\bwernicke\b/i, /\bsensory\b/i, /\breceptive\b/i, /\btranscortical\s*sensory\b/i, /\btcsa\b/i];
    let expr = exprKeys.some(r=>r.test(d)); let recep = recepKeys.some(r=>r.test(d));
    if (/\bglobal\b/i.test(d)){ expr=true; recep=true; }
    if(!(expr||recep)){
      const flu = (p.match(/fluency\s*:\s*([A-Za-z\-]+)/i)||[])[1];
      const comp = (p.match(/comprehension\s*:\s*([A-Za-z\-]+)/i)||[])[1];
      const isImp = (v)=> v && /(impaired|poor|decreased|abnormal|non\-?fluent|aphasia)/i.test(v);
      if(isImp(flu)) expr = true; if(isImp(comp)) recep = true;
    }
    if(!(expr||recep)){
      const m = (d+'\n'+p).match(/aphasia\s*\(\s*([+-])\s*\)/i); if(m && m[1]==='+') expr = true;
    }
    return {expr, recep};
  }
  function inferSpeechSwallowTrach(dx, pet){
    const d = safeLower(dx||''), p = safeLower(pet||'');
    // dysarthria
    let dysarthria=false;
    if(/dysarthria\s*\(\s*\-\s*\)/i.test(d+'\n'+p)) dysarthria=false; else if(/dysarthria\s*\(\s*\+\s*\)/i.test(d+'\n'+p)) dysarthria=true; else if(/\bdysarthria\b/i.test(d+'\n'+p)) dysarthria=true;
    // NG / trach
    const lines = (pet||'').split(/\n+/).map(s=>s.trim().toLowerCase()).filter(Boolean); let ng=false, tr=false;
    for(let i=lines.length-1;i>=0;i--){ const ln=lines[i]; if(ln.startsWith('local finding')){ if(/ng[^a-z0-9]*\+/i.test(ln)) ng=true; if(/(tracheostomy|tr\.)[^a-z0-9]*\+/i.test(ln)) tr=true; break; } }
    if(/\btracheostomy\b.*\(\+\)/i.test(d+'\n'+p)) tr=true;
    // dysphagia
    const dxHas = /\bdysphagia\b/i.test(d) && !/(no|without)\s+dysphagia|dysphagia\s*\(\s*\-\s*\)/i.test(d);
    const pePlus = /dysphagia\s*\(\s*\+\s*\)/i.test(p);
    const peMinus= /dysphagia\s*\(\s*\-\s*\)/i.test(p);
    let dysphagiaAny = false;
    if(ng) dysphagiaAny=true; else if(dxHas) dysphagiaAny=true; else if(pePlus) dysphagiaAny=true; else if(peMinus) dysphagiaAny=false; else dysphagiaAny=false;
    return {dysarthria, dysphagiaAny, trachPlus: tr, ngPlus: ng};
  }

  // ===== Functional status è§£æ =====
  function parseFunctionalComponents(pet){
    const t = safeLower(pet||'');
    const pick = (pat)=>{ const m=t.match(new RegExp(pat+"[^.\n]{0,40}(poor|fair~good|fair|good)", 'i')); return m? m[1]: null };
    return {
      rolling:   pick("\\brolling\\b"),
      sit_up:    pick("\\bsit(?:ting)?(?:\\s*up)?\\b(?![^.\\n]*balance)"),
      sit_bal:   pick("\\bsitting\\s*balance\\b"),
      transfer:  pick("\\btransfer\\b"),
      stand_up:  pick("\\bstanding(?:\\s*up)?\\b(?![^.\\n]*balance)"),
      stand_bal: pick("\\bstanding\\s*balance\\b"),
      walk:      pick("\\b(ambulation|walking|gait|walk)\\b"),
    };
  }
  function inferMobilityFromFunction(pet){
    const comp = parseFunctionalComponents(pet); const hasAny = Object.values(comp).some(v=>!!v) || /\b(ambulation|walking|gait|walk)\b/i.test(pet||'');
    if(!hasAny) return '';
    let mobility;
    if (comp.rolling==='poor' && comp.sit_up==='poor') mobility='Bed ridden';
    else{
      if (comp.sit_up==='poor' && ['fair','fair~good','good'].includes(comp.sit_bal||'')) mobility='W/C care';
      else{ const bucket=[comp.sit_up, comp.transfer, comp.stand_up, comp.sit_bal, comp.stand_bal]; const cnt=bucket.filter(x=>['fair','fair~good','good'].includes(x||'')).length; mobility = (cnt>=2)? 'W/C activity':'W/C care'; }
    }
    const txt = safeLower(pet||'');
    if (/\bwalk(?:ing)?\s+(with|using)\s+(a\s*)?walker\b/i.test(txt) || /\bwalker\b/i.test(txt)) return 'walker';
    if (/\bfree\s*ambulation\b/i.test(txt) || /\bwalk(?:ing)?\s+(independent|independently)\b/i.test(txt) || /\bwalk(?:ing)?\s+without\s+(a\s*)?(walker|aid|assistive\s*device)\b/i.test(txt)) return 'Free ambulation';
    if (comp.walk==='good' || comp.walk==='fair~good') return 'Free ambulation';
    if (comp.walk==='poor') return 'walker';
    return mobility;
  }
  function inferTransferFromFunction(pet){
    const level = parseFunctionalComponents(pet).transfer; if(level==='good') return 'Good'; if(level==='fair~good') return 'Fair~good'; if(level==='fair') return 'Fair'; if(level==='poor') return 'Poor'; return '';
  }

  // ===== Barthel Index å€å¡Šæ“·å– =====
  function extractBarthelBlock(pet){
    if(!pet) return null; const lines = pet.split(/\n/); let start=-1;
    for(let i=0;i<lines.length;i++){ if(/^\s*barthel\s*index\b/i.test(lines[i]) || /^\s*BARTHEL\s*INDEX\s*$/i.test(lines[i])){ start=i; break; } }
    if(start<0) return null; let buff=[];
    for(let i=start;i<lines.length;i++){
      const ln = lines[i]; if(!ln.trim() && buff.length) break; if(/^={3,}/.test(ln)) break; if(/^\s*(Local finding|Functional status|COORDINATION|OTHER NEUROLOGICAL|SENSORY FUNCTION)\b/i.test(ln)) break; buff.push(ln.replace(/\s+$/,''));
    }
    return buff.length? buff.join('\n').trim(): null;
  }

  // ===== SCIï¼šå¾ MP/ASIA è¡¨ä¼° MMT (RUL/RLL/LUL/LLL) =====
  function _pickMinScoreToken(tokens){
    if(!tokens || !tokens.length) return null; const tokMin=(tok)=>{ if(!tok) return Infinity; tok = tok.trim().toUpperCase(); if(tok==='NT') return Infinity; const nums = tok.match(/[0-5]/g); return nums? Math.min(...nums.map(n=>+n)): Infinity; };
    return tokens.slice().sort((a,b)=> tokMin(a)-tokMin(b))[0];
  }
  function parseMMT_UL_LL_FromPE(pet){
    let RUL='NA', RLL='NA', LUL='NA', LLL='NA'; const text = pet||'';
    const m = text.match(/M\.?P\.?\s*:\s*\(0-5\)([\s\S]*?)\n={3,}/i);
    function collect(src, limb, part, side){
      const re = new RegExp(limb+"\\s+"+part+"\\s+([0-5][+-]?|NT)\\s+([0-5][+-]?|NT)", 'ig'); let toks=[]; let mm; while((mm=re.exec(src))){ toks.push(side==='R'? mm[1]: mm[2]); } return toks; }
    if(m){ const block=m[1];
      const r_ul = _pickMinScoreToken(collect(block,'upper','proximal','R')) || _pickMinScoreToken(collect(block,'upper','distal','R'));
      const l_ul = _pickMinScoreToken(collect(block,'upper','proximal','L')) || _pickMinScoreToken(collect(block,'upper','distal','L'));
      const r_ll = _pickMinScoreToken(collect(block,'lower','proximal','R')) || _pickMinScoreToken(collect(block,'lower','distal','R'));
      const l_ll = _pickMinScoreToken(collect(block,'lower','proximal','L')) || _pickMinScoreToken(collect(block,'lower','distal','L'));
      if(r_ul) RUL=r_ul; if(l_ul) LUL=l_ul; if(r_ll) RLL=r_ll; if(l_ll) LLL=l_ll; return {RUL,RLL,LUL,LLL};
    }
    // fallback: ASIA rows
    const levels=['C5','C6','C7','C8','T1','L2','L3','L4','L5','S1'];
    const asia = {R:{}, L:{}};
    function grab(level){
      let m1 = text.match(new RegExp('^\\s*([0-5][+-]?|[0-5]\\s*-\\s*[0-5])\\s*'+level+'\\b.*?([0-5][+-]?|[0-5]\\s*-\\s*[0-5])\\s*$', 'im'));
      if(m1) return [m1[1], m1[2]];
      let m2 = text.match(new RegExp(level+'\\b.*?([0-5][+-]?|[0-5]\\s*-\\s*[0-5]).*?([0-5][+-]?|[0-5]\\s*-\\s*[0-5])', 'is'));
      if(m2) return [m2[1], m2[2]]; return [null,null];
    }
    levels.forEach(lv=>{ const [r,l] = grab(lv); if(r) asia.R[lv]=r; if(l) asia.L[lv]=l; });
    const r_ul = _pickMinScoreToken(['C5','C7'].map(k=>asia.R[k]).filter(Boolean)) || _pickMinScoreToken(['C6','C8','T1'].map(k=>asia.R[k]).filter(Boolean));
    const l_ul = _pickMinScoreToken(['C5','C7'].map(k=>asia.L[k]).filter(Boolean)) || _pickMinScoreToken(['C6','C8','T1'].map(k=>asia.L[k]).filter(Boolean));
    const r_ll = _pickMinScoreToken(['L2','L3'].map(k=>asia.R[k]).filter(Boolean)) || _pickMinScoreToken(['L4','L5','S1'].map(k=>asia.R[k]).filter(Boolean));
    const l_ll = _pickMinScoreToken(['L2','L3'].map(k=>asia.L[k]).filter(Boolean)) || _pickMinScoreToken(['L4','L5','S1'].map(k=>asia.L[k]).filter(Boolean));
    if(r_ul) RUL=r_ul; if(l_ul) LUL=l_ul; if(r_ll) RLL=r_ll; if(l_ll) LLL=l_ll; return {RUL,RLL,LUL,LLL};
  }

  // MP å¹³å‡
  function parseMP_FromPE(pet){
    const t = pet||''; let rVals=[], lVals=[];
    function pushAll(arr, rex){ findAll(rex, t).forEach(m=>arr.push(_mpToFloat(m[1]))); }
    pushAll(rVals, /\bR(?:ight)?[^:\n]{0,20}MP\s*[:ï¼š]?\s*([0-5][+-]?|[0-5]\s*-\s*[0-5])/ig);
    pushAll(lVals, /\bL(?:eft)?[^:\n]{0,20}MP\s*[:ï¼š]?\s*([0-5][+-]?|[0-5]\s*-\s*[0-5])/ig);
    pushAll(rVals, /MP\s*\(\s*R(?:ight)?\s*\)\s*[:ï¼š]?\s*([0-5][+-]?|[0-5]\s*-\s*[0-5])/ig);
    pushAll(lVals, /MP\s*\(\s*L(?:eft)?\s*\)\s*[:ï¼š]?\s*([0-5][+-]?|[0-5]\s*-\s*[0-5])/ig);
    findAll(/\b(R|L)(?:UE|LE)\b[^:\n]{0,20}MP\s*[:ï¼š]?\s*([0-5][+-]?|[0-5]\s*-\s*[0-5])/ig, t).forEach(m=>{
      (m[1].toUpperCase()==='R'? rVals:lVals).push(_mpToFloat(m[2]));
    });
    if(!rVals.length && !lVals.length){ // fallback: ASIA rows
      const levels=['C5','C6','C7','C8','T1','L2','L3','L4','L5','S1'];
      levels.forEach(lv=>{
        const m = t.match(new RegExp('^\\s*([0-5][+-]?|[0-5]\\s*-\\s*[0-5])\\s*'+lv+'\\b.*?([0-5][+-]?|[0-5]\\s*-\\s*[0-5])\\s*$', 'im'))
               || t.match(new RegExp(lv+'\\b.*?([0-5][+-]?|[0-5]\\s*-\\s*[0-5]).*?([0-5][+-]?|[0-5]\\s*-\\s*[0-5])', 'is'));
        if(m){ rVals.push(_mpToFloat(m[1])); lVals.push(_mpToFloat(m[2])); }
      });
    }
    const avg=(a)=>{ a=a.filter(x=>!isNaN(x)); return a.length? a.reduce((p,c)=>p+c,0)/a.length : NaN };
    const R=avg(rVals), L=avg(lVals); let ALL;
    if(!isNaN(R)&&!isNaN(L)) ALL=(R+L)/2; else if(!isNaN(R)) ALL=R; else if(!isNaN(L)) ALL=L; else ALL=NaN;
    return {R,L,all:ALL};
  }

  // ===== è§£æ HTML â†’ æ²»ç™‚è¨ˆç•« =====
  function parseTreatmentsFromHTML(html){
    const txt = (html||'').replace(/\s+/g,' ').toLowerCase();
    const has = (...keys)=> keys.some(k=> txt.includes(k.toLowerCase()));
    const result = {
      PT: { 'PROM':false, 'å‚¾æ–œå°':false, 'ä¿ƒé€²':false, 'é‹å‹•':false, 'è½‰ä½':false, 'è‚ŒåŠ›':false, 'è€åŠ›':false, 'è¡Œèµ°':false, 'æ­¥æ…‹':false, 'ç†±æ•·':false, 'é›»ç™‚':false },
      OT: { 'PROM':false, 'å§¿æ…‹':false, 'è‚ŒåŠ›':false, 'åç«™å¹³è¡¡':false, 'æ—¥å¸¸ç”Ÿæ´»':false, 'æŒæŒ‡åŠŸèƒ½':false, 'å”èª¿':false, 'ä¸Šä¸‹è‚¢åŠŸèƒ½':false, 'é‹å‹•æ„Ÿè¦º':false },
      ST: { 'å¤±èªç—‡':false, 'ååš¥å›°é›£':false, 'æ§‹éŸ³å›°é›£':false },
      PSY:{ 'æˆäººæ”¯æŒ':false, 'è¡Œç‚ºæ²»ç™‚è¨ˆç•«':false, 'æˆäººå¿ƒç†ç”Ÿç†':false, 'å¿ƒç†æ¸¬è©¦':false, 'äººæ ¼ç‰¹è³ª':false },
      NURSE:{ 'è‡ªæˆ‘ç…§é¡§èƒ½åŠ›':true, 'æ¥å—è¡›æ•™èƒ½åŠ›':true, 'ç”¨è—¥æŒ‡å°':true, 'è·Œå€’å±éšªå› å­':true, 'èº«é«”æ´»å‹•åŠŸèƒ½':true }
    };
    // PT
    if(has('ptm5','passive r.o.m','passive rom','è¢«å‹•æ€§é—œç¯€é‹å‹•')) result.PT['PROM']=true;
    if(has('ptm8','tilting table')) result.PT['å‚¾æ–œå°']=true;
    if(has('ptc1','facilitation techniques','ä¿ƒé€²æŠ€è¡“','å§¿å‹¢è¨“ç·´','posture training','ptm13')) result.PT['ä¿ƒé€²']=true;
    if(has('ptm7','therapeutic ex','ptm6','stretching')) result.PT['é‹å‹•']=true;
    if(has('ptm9','strengthening')) result.PT['è‚ŒåŠ›']=true;
    if(has('ptm10','endurance')) result.PT['è€åŠ›']=true;
    if(has('ptc6','ambulation training','è¡Œèµ°è¨“ç·´')){ result.PT['è¡Œèµ°']=true; result.PT['æ­¥æ…‹']=true; }
    if(has('pts2','hot\\cold pack','hot cold pack','ç†±æ•·') || has('pts4','paraffin')) result.PT['ç†±æ•·']=true;
    if(has('pts8','interferential') || has('pts9','tens') || has('ptm1','muscle stimulation') || has('pts11','low power laser') || has('pts10','high frequency discharge')) result.PT['é›»ç™‚']=true;
    // OT
    if(has('ot2','è¢«å‹•æ€§é—œç¯€è¨“ç·´','passive')) result.OT['PROM']=true;
    if(has('ot1','posture training','å§¿æ…‹è¨“ç·´')) result.OT['å§¿æ…‹']=true;
    if(has('ot6','muscle strenght','muscle strength')) result.OT['è‚ŒåŠ›']=true;
    if(has('ot3','åç«™å¹³è¡¡','sitting balance')) result.OT['åç«™å¹³è¡¡']=true;
    if(has('ot5','adl training','æ—¥å¸¸ç”Ÿæ´»')) result.OT['æ—¥å¸¸ç”Ÿæ´»']=true;
    if(has('ot10','hand on foot function','æŒæŒ‡åŠŸèƒ½')) result.OT['æŒæŒ‡åŠŸèƒ½']=true;
    if(has('ot11','coordination','å”èª¿è¨“ç·´')) result.OT['å”èª¿']=true;
    if(has('ot8','u/e or l/e function training','ä¸Šè‚¢(ä¸‹è‚¢)åŠŸèƒ½è¨“ç·´','ä¸Šä¸‹è‚¢åŠŸèƒ½')) result.OT['ä¸Šä¸‹è‚¢åŠŸèƒ½']=true;
    if(has('ot7','motion sensory','é‹å‹•çŸ¥è¦º','sensory')) result.OT['é‹å‹•æ„Ÿè¦º']=true;
    // ST/PSY
    if(txt.includes('ååš¥') || txt.includes('oral tx')) result.ST['ååš¥å›°é›£']=true;
    if(txt.includes('æ§‹éŸ³') || txt.includes('dysarthria')) result.ST['æ§‹éŸ³å›°é›£']=true;
    if(['èªè¨€æ²»ç™‚','auditory comprehension','verbal production'].some(k=>txt.includes(k))) result.ST['å¤±èªç—‡']=true;
    if(txt.includes('è¡Œç‚ºæ²»ç™‚è¨ˆç•«')) result.PSY['è¡Œç‚ºæ²»ç™‚è¨ˆç•«']=true;
    if(['å¿ƒç†æ¸¬æª¢','å¿ƒç†æ¸¬è©¦','é›»è…¦åŒ–ç¥ç¶“å¿ƒç†æ¸¬é©—'].some(k=>txt.includes(k))) result.PSY['å¿ƒç†æ¸¬è©¦']=true;
    if(txt.includes('äººæ ¼ç‰¹è³ª')) result.PSY['äººæ ¼ç‰¹è³ª']=true;
    if(['ç”Ÿç†å¿ƒç†åŠŸèƒ½','æˆäºº'].some(k=>txt.includes(k))){ result.PSY['æˆäººå¿ƒç†ç”Ÿç†']=true; result.PSY['æˆäººæ”¯æŒ']=true; }
    return result;
  }
  function applyST_FromAssessment(flags, dx, pet){
    const {expr, recep} = inferAphasiaTypes(dx, pet); const {dysarthria, dysphagiaAny} = inferSpeechSwallowTrach(dx, pet);
    flags.ST = flags.ST || { 'å¤±èªç—‡':false, 'ååš¥å›°é›£':false, 'æ§‹éŸ³å›°é›£':false };
    flags.ST['å¤±èªç—‡'] = !!(expr || recep);
    flags.ST['ååš¥å›°é›£'] = !!dysphagiaAny;
    flags.ST['æ§‹éŸ³å›°é›£'] = !!dysarthria;
    return flags;
  }

  // ===== å‡ºé™¢ç›®æ¨™ =====
  function tokenMinValue(tok){ if(!tok) return Infinity; tok = String(tok).trim().toUpperCase(); if(tok==='NT') return Infinity; const nums = tok.match(/[0-5]/g); return nums? Math.min(...nums.map(n=>+n)) : Infinity; }
  function inferDischargeGoalsFromAll(pet, llToken){
    const goals = { "è‡ªè¡Œç¿»èº«":false, "åå§¿å¹³è¡¡":false, "è‡ªè¡Œè½‰ä½":false, "ç«™ç«‹":false, "è‡ªè¡Œæ“æ§è¼ªæ¤…æ´»å‹•":false, "å”åŠ©æŒè¼”åŠ©å™¨è¡Œèµ°":false, "æŒè¼”åŠ©å™¨ç¨ç«‹è¡Œèµ°":false };
    const comp = parseFunctionalComponents(pet);
    const arr = [comp.rolling, comp.sit_up, comp.transfer, comp.stand_up];
    const allPoor = arr.filter(v=>v!=null).length>=2 && arr.filter(v=>v==='poor').length===arr.filter(v=>v!=null).length;
    const mpAll = parseMP_FromPE(pet).all; const mmt = parseMMT_UL_LL_FromPE(pet); const mmtMin = Math.min(tokenMinValue(mmt.RUL), tokenMinValue(mmt.RLL), tokenMinValue(mmt.LUL), tokenMinValue(mmt.LLL));
    if(allPoor || (!isNaN(mpAll) && mpAll<3) || mmtMin<3){ goals['åå§¿å¹³è¡¡']=true; goals['è‡ªè¡Œè½‰ä½']=true; }
    if(comp.rolling==='poor') goals['è‡ªè¡Œç¿»èº«']=true;
    const txt = safeLower(pet||'');
    if (/\bfree\s*ambulation\b/i.test(txt) || /\bwalk(?:ing)?\s+(independent|independently|without\s+(a\s*)?(walker|aid|assistive\s*device))\b/i.test(txt)) goals['æŒè¼”åŠ©å™¨ç¨ç«‹è¡Œèµ°']=true;
    if ((/\bwalk(?:ing)?\s+(with|using)\s+(a\s*)?walker\b/i.test(txt) || /\bwalker\b/i.test(txt)) && !goals['æŒè¼”åŠ©å™¨ç¨ç«‹è¡Œèµ°']) goals['å”åŠ©æŒè¼”åŠ©å™¨è¡Œèµ°']=true;
    if(['fair','fair~good','good'].includes(comp.stand_up||'')){ goals['è‡ªè¡Œæ“æ§è¼ªæ¤…æ´»å‹•']=true; goals['ç«™ç«‹']=true; }
    if(llToken){ const s = llToken.toUpperCase().replace(/\s+/g,''); if (s.split(/[-\/]/).some(x=>x==='V'||x==='VI')) goals['æŒè¼”åŠ©å™¨ç¨ç«‹è¡Œèµ°']=true; }
    return goals;
  }

  function buildTreatmentBlock(flags){
    function lineFrom(cat, items){ return cat+': '+ items.map(it=> box(flags[cat]?.[it]) + it).join(' '); }
    const pt_items = ['PROM','å‚¾æ–œå°','ä¿ƒé€²','é‹å‹•','è½‰ä½','è‚ŒåŠ›','è€åŠ›','è¡Œèµ°','æ­¥æ…‹','ç†±æ•·','é›»ç™‚'];
    const ot_items = ['PROM','å§¿æ…‹','è‚ŒåŠ›','åç«™å¹³è¡¡','æ—¥å¸¸ç”Ÿæ´»','æŒæŒ‡åŠŸèƒ½','å”èª¿','ä¸Šä¸‹è‚¢åŠŸèƒ½','é‹å‹•æ„Ÿè¦º'];
    const st_items = ['å¤±èªç—‡','ååš¥å›°é›£','æ§‹éŸ³å›°é›£'];
    const psy_items= ['æˆäººæ”¯æŒ','è¡Œç‚ºæ²»ç™‚è¨ˆç•«','æˆäººå¿ƒç†ç”Ÿç†','å¿ƒç†æ¸¬è©¦','äººæ ¼ç‰¹è³ª'];
    const nurse_items=['è‡ªæˆ‘ç…§é¡§èƒ½åŠ›','æ¥å—è¡›æ•™èƒ½åŠ›','ç”¨è—¥æŒ‡å°','è·Œå€’å±éšªå› å­','èº«é«”æ´»å‹•åŠŸèƒ½'];
    const lines=[ 'ã€æ²»ç™‚è¨ˆç•«ã€‘', lineFrom('PT', pt_items), lineFrom('OT', ot_items), lineFrom('ST', st_items), lineFrom('PSY', psy_items), lineFrom('NURSE', nurse_items) ];
    return lines.join('\n');
  }
  function buildDischargeGoals(goals){ const order=["è‡ªè¡Œç¿»èº«","åå§¿å¹³è¡¡","è‡ªè¡Œè½‰ä½","ç«™ç«‹","è‡ªè¡Œæ“æ§è¼ªæ¤…æ´»å‹•","å”åŠ©æŒè¼”åŠ©å™¨è¡Œèµ°","æŒè¼”åŠ©å™¨ç¨ç«‹è¡Œèµ°"]; return 'ã€å‡ºé™¢ç›®æ¨™ã€‘\n'+ order.map(k=> box(!!goals[k])+k).join(' '); }
  function buildPlanAdjustmentFromAssessment(diag, pe){
    const {expr, recep} = inferAphasiaTypes(diag, pe); const isGlobal = expr && recep; const {dysarthria, dysphagiaAny} = inferSpeechSwallowTrach(diag, pe);
    const st = { 'å£è…”å‹•ä½œè¨“ç·´':false, 'ç™¼éŸ³':false, 'ååš¥èƒ½åŠ›':false, 'èªè¨€ç†è§£':false, 'èªè¨€è¡¨é”':false, 'å£èªé•·åº¦':false };
    if(dysphagiaAny){ st['å£è…”å‹•ä½œè¨“ç·´']=true; st['ååš¥èƒ½åŠ›']=true; }
    if(expr||recep||isGlobal){ st['ç™¼éŸ³']=true; st['å£èªé•·åº¦']=true; }
    if(isGlobal){ st['èªè¨€è¡¨é”']=true; st['èªè¨€ç†è§£']=true; } else { if(expr) st['èªè¨€è¡¨é”']=true; if(recep) st['èªè¨€ç†è§£']=true; }
    const {ng, foley, tr} = parseLocalFindingTubes(pe); const nursingTube = (ng||foley||tr);
    const tubeStr = `ï¼ˆ${ng? 'â– NG':'â–¡NG'} ${foley? 'â– Foley':'â–¡Foley'} ${tr? 'â– Tr.':'â–¡Tr.'}ï¼‰`;
    const ptot = 'PT&OT: '+ [ box(false)+'PROM', box(true)+'ç§»ä½è¨“ç·´', box(true)+'åå§¿å¹³è¡¡', box(true)+'è‚ŒåŠ›', box(true)+'ç«™ç«‹å¹³è¡¡', box(true)+'æŒæŒ‡åŠŸèƒ½', box(true)+'æ­¥æ…‹', box(false)+'è€åŠ›', box(true)+'æ—¥å¸¸ç”Ÿæ´»', box(true)+'å”èª¿', box(false)+'èªçŸ¥åŠŸèƒ½', box(false)+'é›»ç™‚', box(false)+'å…¶ä»–:____' ].join(' ');
    const stLine = 'ST: '+ [ box(st['å£è…”å‹•ä½œè¨“ç·´'])+'å£è…”å‹•ä½œè¨“ç·´', box(st['ç™¼éŸ³'])+'ç™¼éŸ³', box(st['ååš¥èƒ½åŠ›'])+'ååš¥èƒ½åŠ›', box(st['èªè¨€ç†è§£'])+'èªè¨€ç†è§£', box(st['èªè¨€è¡¨é”'])+'èªè¨€è¡¨é”', box(st['å£èªé•·åº¦'])+'å£èªé•·åº¦' ].join(' ');
    const psyLine= 'Psy: '+ [ box(true)+'èªçŸ¥åŠŸèƒ½', box(true)+'æ³¨æ„åŠ›', box(false)+'è¨˜æ†¶åŠ›', box(false)+'åŸ·è¡ŒåŠŸèƒ½', box(false)+'æƒ…ç·’æ§åˆ¶', box(true)+'å®¶å±¬è«®è©¢', box(true)+'ç–¾ç—…é©æ‡‰' ].join(' ');
    const nurseLine='è­·ç†: '+ [ box(true)+'è‡ªæˆ‘ç…§é¡§èƒ½åŠ›', box(nursingTube)+'ç®¡è·¯ç…§é¡§èˆ‡ç§»é™¤'+tubeStr, box(true)+'è·Œå€’é é˜²', box(false)+'çš®è†š/å‚·å£ç…§é¡§', box(false)+'æ„ŸæŸ“é é˜²', box(false)+'å®‰ç½®' ].join(' ');
    return 'ã€æ²»ç™‚è¨ˆç•«ä¿®æ­£èˆ‡åŠ å¼·ã€‘\n'+ [ptot, stLine, psyLine, nurseLine, 'å®¶å±¬:', 'å…¨äºº:'].join('\n');
  }

  function buildClinicalAssessmentBlock(dx, pet){
    const caseType = detectCaseType(dx);
    const sideMp = inferHemiparesisSideFromMP(pet);
    const sideDiag = inferHemiparesisSide(dx);
    const b = parseBrunnstromBlock(pet); // {side, up, ud, ll}
    const sideLocal = (()=>{
      const t = safeLower(pet||''); const m = t.match(/local\s*finding\s*:\s*(.+)/i); const seg = m? m[1]: t;
      if(/\bright[^a-z]{0,3}(hemiplegia|hemiparesis)\b/i.test(seg) || /\brt\.?\b[^.\n]{0,10}(hemiplegia|hemiparesis)\b/i.test(seg)) return 'right';
      if(/\bleft[^a-z]{0,3}(hemiplegia|hemiparesis)\b/i.test(seg) || /\blt\.?\b[^.\n]{0,10}(hemiplegia|hemiparesis)\b/i.test(seg)) return 'left';
      return null;
    })();
    const side = (sideMp || sideLocal || sideDiag || (b.side? b.side.toLowerCase(): null) || 'right');

    const {expr, recep} = inferAphasiaTypes(dx, pet);
    const {dysarthria, dysphagiaAny, trachPlus, ngPlus} = inferSpeechSwallowTrach(dx, pet);
    const mobility = inferMobilityFromFunction(pet);
    const transferAbility = inferTransferFromFunction(pet);
    const cog = inferCognitionLevel(pet);
    const mas = defaultMAS();

    let swallowNone=false, swallowMild=false, swallowSevere=false;
    if(ngPlus) swallowSevere=true; else if(dysphagiaAny) swallowMild=true; else swallowNone=true;

    const isGlobal = expr && recep;

    const diagLow = safeLower(dx);
    const hasQuadri = /(tetraplegia|quadriplegia)/i.test(diagLow);
    const hasPara  = /paraplegia/i.test(diagLow);
    const hasHemi  = /(hemiplegia|hemiparesis)/i.test(diagLow);

    let limbText;
    if(hasQuadri){
      limbText = `${box(false)}è‚¢é«”åç™± ${box(false)}é›™ä¸‹è‚¢ç„¡åŠ› ${box(true)}å››è‚¢ç„¡åŠ› ${box(false)}å·¦å´ç„¡åŠ› ${box(false)}å³å´ç„¡åŠ›`;
    }else if(hasPara){
      limbText = `${box(false)}è‚¢é«”åç™± ${box(true)}é›™ä¸‹è‚¢ç„¡åŠ› ${box(false)}å››è‚¢ç„¡åŠ› ${box(false)}å·¦å´ç„¡åŠ› ${box(false)}å³å´ç„¡åŠ›`;
    }else if(hasHemi){
      limbText = `${box(true)}è‚¢é«”åç™± ${box(false)}é›™ä¸‹è‚¢ç„¡åŠ› ${box(false)}å››è‚¢ç„¡åŠ› ${box(side==='left')}å·¦å´ç„¡åŠ› ${box(side==='right')}å³å´ç„¡åŠ›`;
    }else{
      limbText = `${box(true)}è‚¢é«”åç™± ${box(false)}é›™ä¸‹è‚¢ç„¡åŠ› ${box(false)}å››è‚¢ç„¡åŠ› ${box(side==='left')}å·¦å´ç„¡åŠ› ${box(side==='right')}å³å´ç„¡åŠ›`;
    }

    const lines = [];
    lines.push('ã€è‡¨åºŠè©•ä¼°ã€‘');
    lines.push(limbText);
    lines.push('ç§»å‹•æ–¹å¼ '+ [ `${box(mobility==='Bed ridden')}Bed ridden`, `${box(mobility==='W/C care')}W/C care`, `${box(mobility==='W/C activity')}W/C activity`, `${box(mobility==='walker')}walker`, `${box(mobility==='Free ambulation')}Free ambulation` ].join(' '));
    lines.push('ç§»ä½èƒ½åŠ› '+ [ `${box(transferAbility==='Good')}Good`, `${box(transferAbility==='Fair~good')}Fair~good`, `${box(transferAbility==='Fair')}Fair`, `${box(transferAbility==='Poor~fair')}Poor~fair`, `${box(transferAbility==='Poor')}Poor` ].join(' '));

    const sideCap = String(side).startsWith('r')? 'Right':'Left';
    if(caseType==='CVA'){
      lines.push(`Brunnstrom stage: ${sideCap}   up / ud / ll: ${b.up} / ${b.ud} / ${b.ll}`);
    }else if(caseType==='SCI'){
      const mmt = parseMMT_UL_LL_FromPE(pet);
      lines.push(`MMT: RUL/RLL: ${mmt.RUL} / ${mmt.RLL}   LUL/LLL: ${mmt.LUL} / ${mmt.LLL}`);
      const barthel = extractBarthelBlock(pet); if(barthel) lines.push(barthel);
    }else if(caseType==='TBI'){
      const barthel = extractBarthelBlock(pet); if(barthel) lines.push(barthel);
    }

    lines.push('ç—™æ”£spasticity: Right (elbow/wrist/finger, knee/ankle):'+ `${mas.R1},${mas.R2}`);
    lines.push('              (MAS)Left (elbow/wrist/finger, knee/ankle):'+ `${mas.L1},${mas.L2}`);
    lines.push('ååš¥éšœç¤™ '+ [ `${box(swallowNone)}ç„¡`, `${box(swallowMild)}è¼•åº¦ã€éœ€ç›£è¦–`, `${box(swallowSevere)}åš´é‡ã€éœ€é¼»èƒƒç®¡` ].join(' '));
    lines.push('èªè¨€éšœç¤™ '+ [ `${box(!(expr||recep||dysarthria||trachPlus))}ç„¡`, `${box(expr && !isGlobal)}è¡¨é”æ€§å¤±èªç—‡`, `${box(recep && !isGlobal)}æ¥å—æ€§å¤±èªç—‡`, `${box(isGlobal)}çƒæ€§å¤±èªç—‡`, `${box(dysarthria)}æ§‹éŸ³ç•°å¸¸`, `${box(trachPlus)}æ°£åˆ‡` ].join(' '));
    lines.push(`èªçŸ¥éšœç¤™ ${box(cog==='å·®')}å·® ${box(cog==='å°šå¯')}å°šå¯ ${box(cog==='è‰¯')}è‰¯`);
    lines.push(`é—œç¯€æ”£ç¸® ${box(true)}ç„¡ ${box(false)}æœ‰ã€éƒ¨ä½________________`);
    return lines.join('\n');
  }

  function buildDischargeGoalsBlock(pet){ const {ll} = parseBrunnstromBlock(pet); const goals = inferDischargeGoalsFromAll(pet, ll); return buildDischargeGoals(goals); }
  function generateReport(dx, pet, html){
    const assessment = buildClinicalAssessmentBlock(dx, pet);
    let flags = parseTreatmentsFromHTML(html);
    flags = applyST_FromAssessment(flags, dx, pet);
    const treatment = buildTreatmentBlock(flags);
    const goals = buildDischargeGoalsBlock(pet);
    const adjust = buildPlanAdjustmentFromAssessment(dx, pet);
    return [assessment, treatment, goals, adjust].join('\n\n');
  }

  // ===== UI ç¶å®š =====
  $('#gen').addEventListener('click', ()=>{
    const dx = diagnosis.value.trim(); const pet = pe.value.trim(); if(!dx && !pet){ status.textContent='è«‹è‡³å°‘è¼¸å…¥ Diagnosis æˆ– PE'; status.className='warn tiny'; return; }
    const rpt = generateReport(dx, pet, htmltext.value||''); out.textContent = rpt; status.textContent='å·²ç”¢ç”Ÿå ±å‘Š'; status.className='ok tiny';
  });
  $('#copy').addEventListener('click', async()=>{
    try{ await navigator.clipboard.writeText(out.textContent||''); status.textContent='å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿'; status.className='ok tiny'; }catch(e){ status.textContent='è¤‡è£½å¤±æ•—'; status.className='warn tiny'; }
  });
  $('#save').addEventListener('click', ()=>{
    const blob = new Blob([out.textContent||''], {type:'text/plain;charset=utf-8'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download='Grandrun_Report.txt'; a.click(); URL.revokeObjectURL(a.href);
  });
})();
</script>
</body>
</html>
